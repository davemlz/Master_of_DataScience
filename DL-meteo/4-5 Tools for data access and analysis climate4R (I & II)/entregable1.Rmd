---
title: 'Índice ID: Señal de Cambio Climático'
output:
  html_document:
    df_print: paged
---

## Eduardo Ruíz Ruíz
## David Montero Loaiza

## Introducción

Diferentes índices ETCCDI han sido generados como indicadores del cambio climático (Clivar, 2009). En este estudio se utilizó el índice Icing Days (ID) como índicador del cambio climático. El índice ETCCDI ID utiliza la variable de temperatura máxima $TX$ diaria en grados centigrados para calcular el número de días al año en que la temperatura máxima diaria fue menor que 0 ($TX<0$).

Teniendo en cuenta 3 modelos de CORDEX (Europa), se evaluó si mediante el índice ID se podía detectar una señal de cambio climático que, en este caso, afectara la cantidad de días al año en que la temperatura máxima diaria fuera menor que 0. Los 3 modelos de CORDEX usados fueron el CCLM5, el RACMO22E y el RCA4, todos a una resolución espacial de 0.44 grados decimales.

## Materiales y Métodos

### Área de estudio

El área de estudio de este trabajo comprendió a la península Escandinava (Noruega, Suecia y Finlandia). Las coordenadas de la extensión del área de estudio estan dadas por una longitud mínima de 3.6 E, una longitud máxima de 33.9 E, una latitud mínima de 54.4 N y una latitud máxima de 71.5 N.

```{r}
lonLim = c(3.6,33.9)
latLim = c(54.4,71.5)
```

### Períodos de estudio

Dos períodos de estudio, de 30 años cada uno, se tuvieron en cuenta para calcular la señal de cambio climático: un período histórico que comprende los años 1971-2000, y un período futuro, que comprende los años 2031-2060.

```{r}
years.historical = 1971:2000
years.future = 2031:2060
```

Durante cada uno de los años se decidió evaluar la totalidad de los meses del año y no sólo una estación en particular.

```{r}
seasons = 1:12
```

### Climate4R

Se utilizó el paquete climate4R (Iturbide et al., 2019) para cargar, procesar y analizar los datos.

```{r}
library(visualizeR)
library(loadeR)
require(transformeR)
require(RColorBrewer)
```

Dos paletas de colores se definieron para visualizar el índice ID y la señal de cambio climático, respectivamente.

```{r}
colsindex = rev(brewer.pal(n = 9, "RdYlBu"))
colsdelta = brewer.pal(n = 9, "Reds")
```

Se accedió a los datasets utilizando la plataforma de UDG.

```{r}
password = read.table("C:/Users/Dave Mont/Desktop/Master_of_DataScience/DL-meteo/pass.txt",header = TRUE)
loginUDG(username = toString(password$user), password = toString(password$password))
```

### Señal de Cambio Climático

Se generó una función que carga los datos históricos (*historicalData*) y futuros (*futureData*) para un dominio espacial dado (*xExtent* e *yExtent*), un rango temporal histórico (*historicalYears*), un rango temporal futuro (*futureYears*), un conunto de meses de estudio (*seasons*) y una variable objetivo (*variable*).

Sobre esta carga de datos se pueden realizar ciertas operaciones, como agregaciones mensuales (*aggregation.m*), agregaciones anuales (*aggregation.y*), aplicar una condición (*condition*) sobre un umbral (*threshold*) y usar un diccionario si es necesario (*dictionary*).

La función tiene la opción de interpolar (*interpolate*) los datos para reproyectar las imágenes a un sistema de coordenadas proyectado en Latitud y Longitud según un tamaño de píxel determinado (*pixelSize*).

Finalmente, la función calcula la resta entre los datos futuros e historicos para obtener la Señal de Cambio Climático (CCS), dando la opción de retornar sólo la señal o también los datos usados (*onlyCCS*).

```{r}
getCCSignal = function(historicalData,
                       futureData,
                       xExtent,
                       yExtent,
                       historicalYears,
                       futureYears,
                       seasons,
                       variable,
                       aggregation.m = "sum",
                       aggregation.y = "sum",
                       condition,
                       threshold,
                       dictionary,
                       interpolate = TRUE,
                       pixelSize = 0.5,
                       onlyCCS = FALSE){
  
  print("Cargando datos históricos y futuros...")
  pb = txtProgressBar(min = 0, max = 2, style = 3)
  
  idx.h = loadGridData(historicalData,
                       var = variable,
                       season = seasons,
                       years = historicalYears,
                       lonLim = xExtent,
                       latLim = yExtent,
                       aggr.m = aggregation.m,
                       condition = condition,
                       threshold = threshold,
                       dictionary = dictionary)
  
  setTxtProgressBar(pb,1)
  
  idx.f = loadGridData(futureData,
                       var = variable,
                       season = seasons,
                       years = futureYears,
                       lonLim = xExtent,
                       latLim = yExtent,
                       aggr.m = aggregation.m,
                       condition = condition,
                       threshold = threshold,
                       dictionary = dictionary)
  
  setTxtProgressBar(pb,2)
  close(pb)
  
  print("Agregando datos...")
  pb = txtProgressBar(min = 0, max = 2, style = 3)
  
  idx.h = aggregateGrid(idx.h,aggr.y = list(FUN = aggregation.y))
  setTxtProgressBar(pb,1)
  
  idx.f = aggregateGrid(idx.f,aggr.y = list(FUN = aggregation.y))
  setTxtProgressBar(pb,2)
  close(pb)
  
  if(interpolate){
    
    print("Interpolando datos...")
    pb = txtProgressBar(min = 0, max = 2, style = 3)
    
    coords = list(x = seq(floor(xExtent[1]),ceiling(xExtent[2]),pixelSize),
                  y = seq(floor(yExtent[1]),ceiling(yExtent[2]),pixelSize))
    
    idx.h = interpGrid(idx.h,new.coordinates = coords)
    setTxtProgressBar(pb,1)
    
    idx.f = interpGrid(idx.f,new.coordinates = coords)
    setTxtProgressBar(pb,2)
    close(pb)
    
  }
  
  print("Calculando CCS...")
  pb = txtProgressBar(min = 0, max = 1, style = 3)
  
  CCsignal = gridArithmetics(idx.f,idx.h,operator = "-")
  setTxtProgressBar(pb,1)
  close(pb)
  
  print("Proceso finalizado")
  
  if(onlyCCS){
    
    return(CCsignal)
    
  }else{
    
    toReturn = list()
    toReturn$idx.h = idx.h
    toReturn$idx.f = idx.f
    toReturn$CCS = CCsignal
    
    return(toReturn)
    
  }
  
}
```

### Modelo (CCLM5)

Se utilizó el RCM de CORDEX a una resolución espacial de 0.44 grados decimales (EUR-44), el primer modelo evaluado fue el CCLM5. Como datos futuros se utilizó el RCP85.

```{r}
CCLM5.h = "http://meteo.unican.es//tds5/dodsC/cordex/EUR-44/day/ETH/ICHEC-EC-EARTH_historical_r12i1p1_CCLM5-0-6_v1_day.ncml"
CCLM5.rcp85 = "http://meteo.unican.es//tds5/dodsC/cordex/EUR-44/day/ETH/ICHEC-EC-EARTH_rcp85_r12i1p1_CCLM5-0-6_v1_day.ncml"
```

Hacemos un inventario para ver las variables disponibles y cuál es su nombre.

```{r}
di.historical = dataInventory(CCLM5.h)
names(di.historical)
```

La variable de temperatura máxima se encuentra bajo el nombre de *tasmax*, así podemos ver su contenido.

```{r}
di.historical$tasmax
```

Como esta variable se encuentra en grados Kelvin, se debe realizar la transformación a Centigrados, por tal motivo se debe crear un diccionario para establecer un *offset* de -273.15 y que los datos resultantes se encuentren en Centigrados:

```{r}
file.create("dic.dic")
writeLines(c("identifier,short_name,time_step,lower_time_bound,upper_time_bound,cell_metod,offset,scale,deaccum,derived,interface","tasmax,tasmax,24h,0,24,max,-273.15,1,0,0,"), "dic.dic")
```

Los datos son cargados online, la variable que se usa es *tasmax* durante los años y meses espeificados en el dominio espacial establecido. Se utiliza el diccionario creado para convertir los datos a Centigrados y ya que el índice ID se basa en los días en que *TX* fue menor que 0, se establece un umbral en 0 y una condición *LT* (Lower Than) para determinar si un día cumplió o no con la condición. Se realiza una agregación mensual para sumar todos los días que cumplen con la condición.

```{r}
CCS.CCLM5 = getCCSignal(historicalData = CCLM5.h,
                        futureData = CCLM5.rcp85,
                        xExtent = lonLim,
                        yExtent = latLim,
                        historicalYears = years.historical,
                        futureYears = years.future,
                        seasons = seasons,
                        variable = "tasmax",
                        aggregation.m = "sum",
                        aggregation.y = "sum",
                        condition = "LT",
                        threshold = 0,
                        dictionary = "dic.dic",
                        interpolate = TRUE,
                        pixelSize = 0.5,
                        onlyCCS = FALSE)
```

### Modelo (RACMO22E)

El mismo procedimiento anterior se repitió para los datos de RACMO22E:

```{r}
RACMO22E.h = "http://meteo.unican.es//tds5/dodsC/cordex/EUR-44/day/KNMI/ICHEC-EC-EARTH_historical_r1i1p1_RACMO22E_v1_day.ncml"
RACMO22E.rcp85 = "http://meteo.unican.es//tds5/dodsC/cordex/EUR-44/day/KNMI/ICHEC-EC-EARTH_rcp85_r1i1p1_RACMO22E_v1_day.ncml"
```

Hacemos un inventario para ver las variables disponibles y cuál es su nombre.

```{r}
di.historical = dataInventory(RACMO22E.h)
names(di.historical)
```

La variable de temperatura máxima se encuentra bajo el nombre de *tasmax*, así podemos ver su contenido.

```{r}
di.historical$tasmax
```

El mismo diccionario anterior creado se utilizó para realizar el ajuste de *offset* de la variable *tasmax*.

```{r}
CCS.RACMO22E = getCCSignal(historicalData = RACMO22E.h,
                           futureData = RACMO22E.rcp85,
                           xExtent = lonLim,
                           yExtent = latLim,
                           historicalYears = years.historical,
                           futureYears = years.future,
                           seasons = seasons,
                           variable = "tasmax",
                           aggregation.m = "sum",
                           aggregation.y = "sum",
                           condition = "LT",
                           threshold = 0,
                           dictionary = "dic.dic",
                           interpolate = TRUE,
                           pixelSize = 0.5,
                           onlyCCS = FALSE)
```

### Modelo (RCA4)

El mismo procedimiento anterior se repitió para los datos de RCA4:

```{r}
RCA4.h = "http://meteo.unican.es//tds5/dodsC/cordex/EUR-44/day/SMHI/ICHEC-EC-EARTH_historical_r12i1p1_RCA4_v1_day.ncml"
RCA4.rcp85 = "http://meteo.unican.es//tds5/dodsC/cordex/EUR-44/day/SMHI/ICHEC-EC-EARTH_rcp85_r12i1p1_RCA4_v1_day.ncml"
```

Hacemos un inventario para ver las variables disponibles y cuál es su nombre.

```{r}
di.historical = dataInventory(RCA4.h)
names(di.historical)
```

La variable de temperatura máxima se encuentra bajo el nombre de *tasmax*, así podemos ver su contenido.

```{r}
di.historical$tasmax
```

El mismo diccionario anterior creado se utilizó para realizar el ajuste de *offset* de la variable *tasmax*.

```{r}
CCS.RCA4 = getCCSignal(historicalData = RCA4.h,
                       futureData = RCA4.rcp85,
                       xExtent = lonLim,
                       yExtent = latLim,
                       historicalYears = years.historical,
                       futureYears = years.future,
                       seasons = seasons,
                       variable = "tasmax",
                       aggregation.m = "sum",
                       aggregation.y = "sum",
                       condition = "LT",
                       threshold = 0,
                       dictionary = "dic.dic",
                       interpolate = TRUE,
                       pixelSize = 0.5,
                       onlyCCS = FALSE)
```

## Resultados y Discusiones

Para visualizar los resultados de los tres modelos evaluados, se unieron como miembros de una única rejilla. Los datos históricos, futuros y de señal de cambio climático se unieron por separado.

```{r}
CCS = bindGrid(CCS.CCLM5$CCS,CCS.RACMO22E$CCS,CCS.RCA4$CCS,dimension = "member")
idx.h = bindGrid(CCS.CCLM5$idx.h,CCS.RACMO22E$idx.h,CCS.RCA4$idx.h,dimension = "member")
idx.f = bindGrid(CCS.CCLM5$idx.f,CCS.RACMO22E$idx.f,CCS.RCA4$idx.f,dimension = "member")
```

En la siguiente gráfica se puede observar el índice ID histórico por cada uno de los modelos, se observa cómo los dos primeros modelos (CCLM5 y RACMO22E) son muy similares, sin embargo, el modelo RCA4 es mucho más conservador y no respresenta un alto valor del índice ID, como sí lo demuestran los otros dos modelos.

```{r}
spatialPlot(climatology(idx.h),
            at = seq(0, 300, 10),
            col.regions = colorRampPalette(colsindex),
            main = "ID Histórico",
            backdrop.theme = "countries")
```

En la siguiente gráfica se puede observar el índice ID futuro por cada uno de los modelos, se observa cómo los dos primeros modelos (CCLM5 y RACMO22E) son muy similares (al igual que en el período histórico), y que el modelo RCA4 sigue siendo mucho más conservador y no respresenta un alto valor del índice ID, como sí lo demuestran los otros dos modelos, aunque, en general, los tres modelos disminuyeron el valor de ID para el período futuro.

```{r}
spatialPlot(climatology(idx.f),
            at = seq(0, 300, 10),
            col.regions = colorRampPalette(colsindex),
            main = "ID Futuro",
            backdrop.theme = "countries")
```

En la siguiente gráfica se puede observar la señal de cambio climático del índice ID en la península escandinava. Se observa cómo en el noreste (Mar de Barents) la señal de cambio climático disminuye a valores de -70 días (similar en el norte de la región), mientras que en la península la señal de cambio climático disminuye a aproximadamente -40 días en los modelos CCLM5 y RCA4, mientras que en el modelo RACMO22E el cambio no es tan fuerte (-20 días aproximadamente), aunque en general se reporta una disminución del índice ID en el período futuro para la península escandinava, al igual que se ha reportado en otras regiones del mundo, como Irán (Rahimzadeh et al., 2009) o china (Kong et al., 2019), e incluso para años no que no fueron tan lejanos, como 2017 (Hong y Ying, 2018) o 2011 (Liang et al., 2014).

```{r}
spatialPlot(climatology(CCS),
            at = seq(-70,0,5),
            col.regions = colorRampPalette(colsdelta),
            main = "ID CCS",
            backdrop.theme = "countries")
```

## Conclusiones

Climate4R es una herramienta de gra utilidad para identificar señales de cambio climático dado un indicador específico, como el índice ETCCDI ID. Fue detectada una señal de cambio climático negativa, indicando una disminución del índice ID, y por lo tanto, una disminución en el número de días con temperaturas máximas menores que 0. Esto indica un calentamiento en la zona de estudio, ya que la temperatura máxima no alcanzaría valores por debajo de cero en el período futuro.

## Referencias

* Clivar. 2009. ETCCDI/CRD Climate Change Indices. http://etccdi.pacificclimate.org/list_27_indices.shtml. Último acceso: 2020-04-28.

* Hong, Y., Ying, S. 2018. Characteristics of extreme temperature and precipitation in China in 2017 based on ETCCDI indices. Advances in Climate Change Research 9: 218-226.

* Iturbide, M., Bedia, J., Herrera, S., Baño-Medina, J., Fernández, J., Frías, M.D., Manzanas, R., San-Martín, S., Cimadevilla, E., Cofiño, A.S., Gutiérrez, J.M. 2019. The R-based climate4R open framework for reproducible climate data access and post-processing. Environmental Modelling & Software 111: 42-54.

* Kong, X., Wang, A., Bi, X., Wang, D. 2019. Assessment of Temperature Extremes in China Using RegCM4 and WRF. Advances in Atmospheric Sciences 36 (4): 363-377.

* Liang, K., Bai, P., Li, J., Liu, C. 2014. Variability of temperature extremes in the Yellow River basin during 1961-2011. Quaternary International 336: 52-64.

* Rahimzadeh, F., Asgari, A., Fattahi, E. 2009. Variability of extreme temperature and precipitation in Iran during recent decades. International Journal of Climatology 29 (3): 329-343.


 

